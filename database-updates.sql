-- Updated database schema for Stripe integration and multi-item orders

-- 1. Update orders table to support Stripe and order totals
ALTER TABLE public.orders 
ADD COLUMN IF NOT EXISTS stripe_session_id TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS stripe_payment_intent_id TEXT,
ADD COLUMN IF NOT EXISTS order_number TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS customer_email TEXT NOT NULL,
ADD COLUMN IF NOT EXISTS customer_first_name TEXT,
ADD COLUMN IF NOT EXISTS customer_last_name TEXT,
ADD COLUMN IF NOT EXISTS customer_phone TEXT,
ADD COLUMN IF NOT EXISTS subtotal DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS shipping_cost DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS tax_amount DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS total_amount DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS currency TEXT DEFAULT 'EUR',
ADD COLUMN IF NOT EXISTS order_status TEXT DEFAULT 'pending' CHECK (order_status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled')),
ADD COLUMN IF NOT EXISTS payment_status TEXT DEFAULT 'pending' CHECK (payment_status IN ('pending', 'paid', 'failed', 'refunded')),
ADD COLUMN IF NOT EXISTS shipping_name TEXT,
ADD COLUMN IF NOT EXISTS shipping_phone TEXT,
ADD COLUMN IF NOT EXISTS shipping_address JSON;

-- 2. Remove single product constraint and make it support multiple items
ALTER TABLE public.orders 
DROP COLUMN IF EXISTS product_id,
DROP COLUMN IF EXISTS size_id;

-- 3. Create order_items table for multiple products per order
CREATE TABLE IF NOT EXISTS public.order_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  order_id bigint NOT NULL,
  product_id uuid NOT NULL,
  product_name TEXT NOT NULL, -- Store name at time of purchase
  product_price DECIMAL(10,2) NOT NULL, -- Store price at time of purchase
  product_image TEXT, -- Store main image URL
  size_name TEXT, -- Store size name instead of ID for historical data
  quantity INTEGER NOT NULL DEFAULT 1,
  line_total DECIMAL(10,2) NOT NULL, -- quantity * product_price
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT order_items_pkey PRIMARY KEY (id),
  CONSTRAINT order_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES orders (id) ON DELETE CASCADE,
  CONSTRAINT order_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES products (id),
  CONSTRAINT order_items_quantity_positive CHECK (quantity > 0),
  CONSTRAINT order_items_price_positive CHECK (product_price > 0),
  CONSTRAINT order_items_total_positive CHECK (line_total > 0)
);

-- 4. Update customers table to be optional and store guest checkout info
CREATE TABLE IF NOT EXISTS public.customers (
  id smallint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  email TEXT UNIQUE NOT NULL,
  first_name TEXT,
  last_name TEXT,
  phone TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT customers_pkey PRIMARY KEY (id)
);

-- 5. Update addresses table to store shipping/billing separately
CREATE TABLE IF NOT EXISTS public.addresses (
  id smallint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  customer_id smallint,
  type TEXT NOT NULL CHECK (type IN ('shipping', 'billing')),
  first_name TEXT,
  last_name TEXT,
  company TEXT,
  address_line1 TEXT NOT NULL,
  address_line2 TEXT,
  city TEXT NOT NULL,
  state TEXT,
  postal_code TEXT NOT NULL,
  country TEXT NOT NULL,
  phone TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT addresses_pkey PRIMARY KEY (id),
  CONSTRAINT addresses_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customers (id)
);

-- 6. Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_orders_stripe_session_id ON orders (stripe_session_id);
CREATE INDEX IF NOT EXISTS idx_orders_customer_email ON orders (customer_email);
CREATE INDEX IF NOT EXISTS idx_orders_order_number ON orders (order_number);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders (created_at);
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product_id ON order_items (product_id);

-- 7. Create function to generate order numbers
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT AS $$
DECLARE
  prefix TEXT := 'PRN';
  timestamp_part TEXT;
  random_part TEXT;
  order_number TEXT;
BEGIN
  -- Get timestamp part (YYYYMMDD)
  timestamp_part := TO_CHAR(NOW(), 'YYYYMMDD');
  
  -- Generate random 4-digit number
  random_part := LPAD((RANDOM() * 9999)::INTEGER::TEXT, 4, '0');
  
  -- Combine parts
  order_number := prefix || timestamp_part || random_part;
  
  -- Check if order number already exists, if so regenerate
  WHILE EXISTS (SELECT 1 FROM orders WHERE order_number = order_number) LOOP
    random_part := LPAD((RANDOM() * 9999)::INTEGER::TEXT, 4, '0');
    order_number := prefix || timestamp_part || random_part;
  END LOOP;
  
  RETURN order_number;
END;
$$ LANGUAGE plpgsql;

-- 8. Create trigger to auto-generate order numbers
CREATE OR REPLACE FUNCTION set_order_number()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.order_number IS NULL THEN
    NEW.order_number := generate_order_number();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_order_number
  BEFORE INSERT ON orders
  FOR EACH ROW
  EXECUTE FUNCTION set_order_number();

-- 9. Sample data cleanup (optional)
-- DELETE FROM orders WHERE id > 0; -- Uncomment if you want to clear existing test data 